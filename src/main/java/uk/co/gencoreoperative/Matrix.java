package uk.co.gencoreoperative;

import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.stream.Stream;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * {@link Matrix} will read in a {@link Stream <Character>} and then perform layout based on the provided dimensions.
 */
public class Matrix {
    private static final Font COURIER_NEW = new Font("Courier New", Font.PLAIN, 12);

    // The number of characters that can be fitted into a line.
    private final int charactersPerLine;

    /**
     * Given a Font and a width, the Matrix will determine the number of characters that can be fitted into
     * the requested width.
     * <p>
     * If the width is less than the width of a single character in the requested font, then an
     * {@link IllegalArgumentException} will be thrown to ensure that the matrix is valid.
     *
     * @param font A possible null {@link Font). If no font is provided, size 12 Courier New will be used.
     * @param widthInPixels A positive integer representing the width of the matrix.
     */
    public Matrix(final int widthInPixels, @Nullable final Font font) {
        if (widthInPixels <= 0) throw new IllegalArgumentException("Width must be greater than 0");
        int averageCharacterWidth = calculateAverageCharacterWidth(font != null? font : COURIER_NEW);

        if (averageCharacterWidth > widthInPixels) throw new IllegalArgumentException("Font is too large for the width");
        charactersPerLine = widthInPixels / averageCharacterWidth;
    }

    /**
     * A simpler constructor that tells the Matrix the number of characters that need to be fitted into a row.
     * @param charactersPerLine A non-negative integer.
     */
    public Matrix(final int charactersPerLine) {
        if (charactersPerLine <= 0) throw new IllegalArgumentException("Width must be greater than 0");
        this.charactersPerLine = charactersPerLine;
    }

    /**
     * A function to calculate the width of the widest character for a given Font.
     * @param font The font that should be tested.
     * @return The width of the widest character.
     */
    public static int calculateAverageCharacterWidth(@Nonnull Font font) {
        // Sample set of characters to scan
        String sampleCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

        // Create a temporary BufferedImage to get FontMetrics
        BufferedImage tempImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
        Graphics graphics = tempImage.getGraphics();
        graphics.setFont(font);
        FontMetrics fontMetrics = graphics.getFontMetrics();

        int maxWidth = 0;
        for (char c : sampleCharacters.toCharArray()) {
            int width = fontMetrics.charWidth(c);
            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth;
    }

    /**
     * Generate a new stream of {@link Character}s by introducing new line characters into the
     * input Character stream at a regular interval.
     * <p>
     * This solution was generated by Co-pilot and works by using the {@link Stream#flatMap(Function)}
     * feature.
     * <p>
     * <pre>
     * the flatMap function creates Streams that are then flattened into a single Stream
     * </pre>
     * <p>
     * The function provided to flatMap will generate a new Stream for each character in
     * the input stream. It then uses this to introduce new line characters at the correct interval.
     * <p>
     * The interval is calculated by using a modulus of the current count and the calculated number
     * of characters per line value.
     *
     * @param input A non-null possibly empty stream.
     * @return A new possibly empty stream.
     */
    public Stream<Character> output(@Nonnull Stream<Character> input) {
        AtomicInteger counter = new AtomicInteger(0);
        // the flatMap function creates Streams that are then flattened into a single Stream
        return input.flatMap(c -> {
            if (counter.incrementAndGet() % charactersPerLine == 0) {
                return Stream.of(c, '\n');
            } else {
                return Stream.of(c);
            }
        });
    }

    public static void main(String... args) {
        Reader reader = new Reader(new File(args[0]));
        new Matrix(50).output(reader.output()).forEach(System.out::print);
    }

//    public Stream<Character> output(Stream<Character> input) {
//        Iterator<Character> supplier = new Iterator<>() {
//            final Iterator<Character> iterator = input.iterator();
//            int counter = 0;
//            Character next = readCharacter();
//
//            @Override
//            public boolean hasNext() {
//                return next != null;
//            }
//
//            @Override
//            public Character next() {
//                Character current = next;
//                next = readCharacter();
//                return current;
//            }
//
//            private Character readCharacter() {
//                Optional<Character> cha = getNext();
//                if (!cha.isPresent()) {
//                    return null;
//                }
//                counter++;
//                if (counter < charactersPerLine) {
//                    return cha.get();
//                } else {
//                    counter = 0;
//                    return '\n';
//                }
//            }
//
//            private Optional<Character> getNext() {
//                return iterator.hasNext() ? Optional.of(iterator.next()) : Optional.empty();
//            }
//        };
//        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(supplier, Spliterator.DISTINCT), false);
//    }
}
